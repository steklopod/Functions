### Классы, композиция и наследование

**`Класс`** является шаблоном для объектов. Когда мы создали класс, мы получаем `возможность создавать его экземпляры` с 
помощью ключевого слова `new`. Данный экземпляр (объект) имеет все свойства и методы, которые имеет класс.

**`Трейт`** – это сущность, которая инкапсулирует поля или методы, которые потом могут быть использованы **для вставки в другие классы**.
Другими словами, трэйт - особый тип скала-класса, который **не может иметь конструкторов**, но **может иметь любые методы и аттрибуты**. 
Обычно они устанавливают некоторый протокол для взаимодействия со своими возможными наследниками. 
Используя этот протокол они могут получить необходимую информацию от потомка и реализовать в нём некоторое поведение. 
Соответственно, любой класс (или объект) может наследоваться от произвольного количества trait'ов (и лишь от одного class'а).

### Наследование
Как и во всех других ООП языках программирования, в Scala поджерживается механизм наследования. 
Для этого используется ключевое слово `extends`, как и в языка Java.
Но, в Scala есть два ограничения:

1. Только первичный конструктор может передавать параметры в базовый конструктор;

2. Переопределение метода требует использования ключевого слова override.

<!-- code -->
```scala
    // sealed говорит о том, что наследники могут  быть назначены только в этом же классе
    sealed trait RunOne{ def run(): Unit = println("Run")}
    
    trait RunTwo       { def run(): Unit = println("Run, Forest!")}
    
    class GoodRunner extends RunOne with RunTwo {
      override def run() = println("Ты не можешь бежать т.к. я переопределил эту функцию :-)")
    }
    
    object GoodRunnerTest extends App {
      println(new GoodRunner().run())
    }
```

### Особенности классов

Давайте опишем несложный класс. Пусть это будет `комлексное число`:

<!-- code -->
```scala
    class Complex(r: Double, i: Double) {
     def real              = r
     def image             = i
     def magnitude         = Math.sqrt(r*r + i*i)
     def angle             = Math.atan2(i, r)
     def + (that: Complex) = new Complex(this.real + that.real, this.image + that.image)
     
     override def toString = real+ " + i*" +image + " | " + magnitude + "*e^(i*" + angle + "))"
    }
    
    object Main extends App {
      val first  = new Complex(1, 5)
      val second = new Complex(2, 4)
      val sum    = first + second
          println(first)
          println(second)
          println(sum)
     }
```
* Во-первых, клас объявлен с какими-то параметрами. Как несложно догадаться по продолжению, это параметры конструктора, 
которые доступны всё время жизни объекта.

* Во-вторых, в классе объявлено несколько методов — селекторов. Одно семейство для декартового представления и одно для полярного. 
Как видим оба они используют параметры конструктора.

* В-третьих, в классе объявлен оператор сложения. Объявлен он как обычный метод, принимает также Complex и возвращает его же.

* Ну и наконец, для этого класса переопределена, без сомнения, знакомая всем Java-программистам функция `toString`. 
Важно отметить что на переопределение методов в Scala всегда необходимо явно указывать при помощи ключевого слова `override`.

Несмотря на огромную практическую ценность **данный класс обладает рядом недостатков**, а именно:

1. Занимает неоправданно много для своей функциональности места на экране

2. Не умеет сравнивать себя с себе подобными

Что же, попробуем исправить недочёты, средствами этого прекрасного языка.

<!-- code -->
```scala
    class Complex(val real: Double, val image: Double) extends Ordered[Complex] {
      def magnitude                   = Math.sqrt(real * real + image * image)
      def angle                       = Math.atan2(image, real)
      def +(that: Complex)            = new Complex(this.real + that.real, this.image + that.image)
      def compare(that: Complex): Int = this.magnitude compare that.magnitude
  
      override def toString = real+" + i*"+image+" | "+magnitude+"*e^(i*"+angle+"))"
    }
    
    object Main extends App {
      val first  = new Complex(1, 5)
      val second = new Complex(2, 4)
    
      if (first > second)   println("Первый больше")
      if (first < second)   println("Второй больше")
      if (first == second)  println("Объекты эквивалентны")
    }
```

_Итак, что появилось нового:_
* У параметров конструктора появилось `ключевое слово val` и `исчезли соответствующие селекторы`. 
Да, всё вполне очевидно, это разрешение компилятору создать селекторы для них автоматически.

* Добавилось наследование от незнакомого нам класса (а точнее trait'а) **`Ordered`**. Да не простого, а параметризованного 
нашим классом. Как следует из названия, он должен помочь нам с упорядочиванием наших экземпляров.

* Появился метод `compare`, который сравнивает два комплексных числа посредством сравнения их модулей.

* В тестовом методе появились использования операторов `>`, `<`, `==`. Их мы явно не определяли.

любой класс (или объект) может наследоваться от произвольного количества trait'ов(и лишь от одного class'а). 
Например `Ordered` объявляет абстрактный метод `compare` и на его основании дополняет класс-наследник операторами `>`, `<`, `=` и т.д.
 Здесь надо заметить, что по-хорошему стоит переопределить предоставленный нам оператор `==`, так как он даёт истину и 
 для неодинаковых объектов, да и методы `equals` с `hashCode` также стоит переопределять в таких случаях.
_«Всё это хорошо» — скажет бывалый боец аутсорсерного рынка, «но что делать если требуется банальный domain-класс, 
с богомерзкими модификаторами атрибутов?».
Решение у нас, естественно, есть :)_

<!-- code -->
```scala
    class User {
      private[this] var _name: String = ""
      def name                  = _name toUpperCase
      def name_=(name: String)  = _name = { if (name != null) name else "" }
    }
```

1. Этот класс использует уже знакомое нам ключевое слово `var` в своём теле, да не просто а с диковинным 
модификатором `private[this]`. Значение этого ключевого слова в теле класса абсолютно аналогично таковому в внутри блока 
(и даже, скажу по секрету, в конструктор его тоже можно запихать) и делает из имени после него изменяемый аттрибут класса. 
Диковинный модификатор заявляет, что переменная должна быть доступна только данному объекту. Можно было написать, 
например, `private[User]` и она стала бы доступна другим, нам подобным, объектам, или указать имя пакета (что-то это мне напоминает).

2. Следует отметить, что тип возвращаемого значения этих двух методов задан неявно. 
Он будет автоматически определён компилятором, который рассмотрит правую часть этих методов и решит что в обоих 
случаях тип возвращаемого значения будет `String`. Компилятор не всегда может вывести тип возвращаемый данных как в 
данном случае, и к сожалению не существует простого правила для точного определения случаев когда это возможно, а когда нет. 
На практике, это не является проблемой, так как компилятор предупреждает о всех случаях, когда он не способен 
определить тип возвращаемого значения. В качестве простого правила для можно предложить следующее руководство к действию –
 _пренебрегать объявлением возвращаемого типа в тех случаях, когда этот тип ясен из контекста, и смотреть как на это
  реагирует компилятор._ Через некоторое время у вас разовьётся внутреннее чутьё подсказывающее когда следует 
  пренебрегать типом, а когда следует его указывать явно.
  
Чтобы понять, как это всё использовать давайте взглянем на результат выполнения следующего 
кода (для краткости я не стал включать сюда описание объекта и main-метода):

<!-- code -->
```scala
    val user = new User("Scala!!!")
    println(user.name)
    user.name = "M. Odersky"
    println(user.name)
```

<!-- code -->
```sbtshell
    SCALA!!!
    M. ODERSKY
```

**Внимание, вывод**: метод с именем `<что-то>_=` вызывается при использовании конструкции `<объект>.<что-то> = <что-то другое>`. 
Насколько я знаю в Scala это второй хак (первый — преобразование `()` в вызов метода `apply`), как Гвидо завещал c 
неявным преобразованием использования оператора в вызов метода.

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)