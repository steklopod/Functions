## for-генеративная подстановка (for comprehensions)

Скала предлагает простую нотацию для выражения последовательностей. 
Подстановки имеют форму `for (enumerators) yield e`, где `enumerators (перечислитель)` ссылаются на список счетчиков, разделенных точкой с запятой.
 **for-запись (for-подстановка)** - это либо **генератор**, который вводит новые переменные, либо **фильтр**. 
 Понятие оценивает тело e для каждого связывания, сгенерированного счетчиками, и возвращает последовательность этих значений.
 
<!-- code -->
```scala
    case class User(name: String, age: Int)
    
    val userBase = List(
      User("Вася", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Дима", 23)
      )
    
    val twentySomethings = for (user <- userBase 
      if user.age >=20 && user.age < 30)
        yield user.name  // т.е. добавить в список
    
    twentySomethings.foreach(name => println(name))  //  Вася Дима
```

Цикл `for`, используемый с оператором `yield`, фактически создает список. Поскольку мы сказали `yield user.name`, 
это `List[String].user <- userBase` - наш генератор, и `if (user.age> = 20 && user.age <30)` является фильтром пользователей, 
которым не исполнилось 20 лет.

Вот более сложный пример с использованием двух генераторов. Он вычисляет `все пары чисел между 0 и n-1`, сумма которых 
равна заданному значению `v`:
 
<!-- code -->
```scala
    def foo(n: Int, v: Int) =
       for (i <- 0 until n;
            j <- i until n if i + j == v)
       yield (i, j)
    
    foo(10, 10) foreach {
      case (i, j) =>
        println(s"($i, $j) ")  // (1, 9) (2, 8) (3, 7) (4, 6) (5, 5)
    }
```
 
Здесь `n = 10` и `v = 10`. На первой итерации `i = 0` и `j = 0` так `i + j! = v`, и поэтому ничего не дано. 
`j` увеличивается до 9 раз, пока `i` не увеличится до 1. Без условия `if` это просто напечатает следующее:

<!-- code -->
```text
    (0, 0) (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (1, 1) ...
```

Обратите внимание, что `for-запись` не ограничивается списками. Каждый тип данных, который поддерживает операции 
`withFilter`, `map` и `flatMap` (с соответствующими типами), может использоваться при последовательном понимании.

Вы можете опустить `yield` в for-записи. В этом случае for-генератор вернет `Unit`. Это может быть полезно, 
если вам необходимо выполнить побочные эффекты. Вот программа, эквивалентная предыдущей, но без использования `yield`:
 
<!-- code -->
```scala
    def foo(n: Int, v: Int) =
       for (i <- 0 until n;
            j <- i until n if i + j == v)
       println(s"($i, $j)")
    
    foo(10, 10)
```
 
_Если этот проект окажется полезным тебе - нажми на кнопочку `star` в правом верхнем углу._

 [<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)
 
