## Вывод типа (type inference)

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/scala666.png?raw=true "OOP.implicit")

Компилятор Scala часто может вывести тип выражения, поэтому вам не нужно явно его объявлять.

### Опускание типа

<!-- code -->
```scala
  val businessName = "Кафе Березка"
```

Компилятор может обнаружить, что `businessName` является строкой. Он работает аналогично методам:

<!-- code -->
```scala
  def squareOf(x: Int) = x * x
```

Компилятор может сделать вывод о том, что тип возвращаемого значения является `Int`, поэтому не требуется явный тип 
возвращаемого значения.

**Для рекурсивных методов компилятор не может вывести тип результата**. Вот программа, которая по ошибке приведет к сбою компилятора:

<!-- code -->
```scala
  def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)
```

Также не обязательно указывать параметры типа, когда вызываются полиморфные методы или генерируются общие классы. 
Компилятор Scala выведет такие параметры отсутствующего типа из контекста и из типов фактических параметров метода/конструктора.

<!-- code -->
```scala
  case class MyPair[A, B](x: A, y: B)
  
  val p = MyPair(1, "scala") // type: MyPair[Int, String]
  
  def id[T](x: T) = x
  val q = id(1)              // type: Int
```

Компилятор использует типы аргументов `MyPair` для определения типов `A` и `B`. Аналогично для типа `x`.

### Параметры
 
Компилятор никогда не вводит типы параметров метода. Однако в некоторых случаях он может вычислить типы параметов 
анонимных функций, когда функция передается как аргумент.

<!-- code -->
```scala
  Seq(1, 3, 4).map(x => x * 2)  // List(2, 6, 8)
```

Параметром для функции `map` является `f: A => B`. Поскольку мы кладем целые числа в `Seq`, компилятор знает, что `A`
 является `Int` (т.е. что `x` является целым числом). Поэтому компилятор может вывести из `x * 2`, что `B` является типом `Int`.

### Когда не стоит полагаться на вывод типа

Обычно код считается более читаемым, чтобы объявлять тип членов, открытых в открытом API. Поэтому мы рекомендовали сделать тип явным для любых API, которые будут доступны пользователям вашего кода.

Кроме того, вывод типа иногда может вызывать слишком специфичный тип. Предположим, что мы пишем:

<!-- code -->
```scala
  var obj = null
```

Мы не можем продолжить и сделать это переопределение:

<!-- code -->
```scala
  obj = new AnyRef
```

Он не будет компилироваться, потому что тип, предполагаемый для `obj`, был `Null`. Поскольку единственное значение 
этого типа равно `null`, и ему невозможно присвоить другое значение.

_Если этот проект окажется полезным тебе - **нажми на кнопочку `star`** в правом верхнем углу._

[<== содержание](https://github.com/steklopod/Functions/blob/master/readme.md)