## Обобщения (genericity)

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/genericity.png "Обобщения")

**Обобщения** – это возможность создавать параметризованный по типам код. 
_Например, программист который пишет библиотеку для связанных списков сталкивается с проблемой «какой тип задать для 
элементов этого списка?»._ Поскольку список может быть использован в различных ситуациях, поэтому нельзя сразу указать 
какие типы будут у его элементов (например все Int-ы). Это может оказаться крайне деспотичным и чрезмерно ограниченным решением.

Java программист прибегает к использованию Object, который является супертипом для всех объектов. 
Это решение тем не менее далеко от идеального, так как не дает возможность работать с примитивными типами 
(int, long, float и т.д.) и заставляет вставлять в программный код большое количество операторов динамического приведения типов.

Scala дает возможность определять обощающие классы (и методы) для того чтобы решить эту проблему. Давайте посмотрим на 
пример простейшего контейнера: ссылка, которая может быть пустой или указывать на объект некоторого типа.

<!-- code -->
```scala
    class Reference[T] {
        private var contents: T = _
        def set(value: T) { contents = value }
        def get: T = contents
    }
```
Класс `Referencе` является параметризованным типом, обозначенным `T`, который является типом этого элемента. 
Этот тип использует в теле класса как тип переменной contents и аргумент метода set,а также тип возвращаемого значения метода `get`.

Приведённый выше код вводит переменную в Scala, которая не требует явного преобразования типа в коде. 
Тем не менее интересно увидеть, что первоначальное значение данной переменной равно `_` , что представляет собой значение 
по умолчанию. Это значение по умолчанию является `0` для численных типов, `false` для `Boolean`, `()` для `Unit` и `null`
 для всех объектных типов.

Для того чтобы использовать `Reference` класс, необходимо указать, какой тип будет использоваться в качестве параметра `T`
, это и будет типом элемента содержащегося в ячейки. Для примера создадим ячейку содержащую `Int`. Мы можно написать 
это в следующем виде:

<!-- code -->
```scala
    object IntegerReference {
        def main(args: Array[String]) {
            val cell = new Reference[Int]
            cell.set(13)
            println("Reference contains the half of " + (cell.get * 2))
        }
    }
```

Как мы можем увидеть в этом примере, нет необходимости перед использование приводить тип к 
Int значение возвращаемое из get-метода. Также не получиться сохранить ничего кроме Int в переменной `cell`, так как 
она была объявлена как хранительница только Int'ов.
![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/scala-inheritance2.png "scala-inheritance")

___

Давайте рассмотрим еще один пример:

**Общие классы** _(generic classes)_ - это классы, которые принимают тип в качестве параметра. Они особенно полезны для классов коллекций.

### Определение общего класса

Обобщенные классы берут `тип` в качестве параметра в квадратных скобках `[]`. Одним из условий является использование 
буквы `A` в качестве идентификатора параметра типа, хотя **любое имя параметра может использоваться**.

<!-- code -->
```scala
    class Stack[A] {
      private var elements: List[A] = Nil
      def push(x: A) { elements = x :: elements }
      def peek: A = elements.head
      def pop(): A = {
        val currentTop = peek
        elements = elements.tail
        currentTop
      }
    }
```

Эта реализация класса `Stack` принимает любой `тип A в качестве параметра`. Это означает, 
что базовый список, элементы `var elements: List[A] = Nil`, могут хранить только элементы типа `A`. Процедура 
`def push` принимает только объекты типа `A` (примечание: `elements = x :: elements` переназначают `elements` в новый 
список, созданный путем добавления `x` к текущим элементам). 

### Использование:

Чтобы использовать общий класс, поместите тип в квадратные скобки вместо `A`.

<!-- code -->
```scala
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
        println(stack.pop)  // 2
        println(stack.pop)  // 1
```

Экземпляра класса `Stack` может принимать только данные. Однако, если аргумент типа имеет подтипы, они могут быть переданы в:

<!-- code -->
```scala
    class Fruit
    class Apple extends Fruit
    class Banana extends Fruit
    
    val stack = new Stack[Fruit]
    val apple = new Apple
    val banana = new Banana
    
    stack.push(apple)
    stack.push(banana)
```

Класс `Apple` и `Banana` расширяют `Fruit`, поэтому мы можем 'заталкивать' экземпляры яблока и банана в стэк `Fruit`.

_**Примечание:** подтипирование родовых типов **инвариантно**. Это означает, что если у нас есть стек символов 
типа `Stack[Char]`, то он не может использоваться как целочисленный стек типа `Stack[Int]`. Это было бы необоснованным, 
потому что это позволило бы нам ввести истинные целые числа в стек символов. В заключение, `Stack[A]` является только 
подтипом `Stack[B]` тогда и только тогда, когда `B = `. Так как это может быть довольно ограничительным,
 Scala предлагает механизм аннотации параметра типа для управления подтипами поведением  обобщенных типов._

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/covariance.png "scala-inheritance")

_Если этот проект окажется полезным тебе - нажми на кнопочку `star` в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)