## Обобщения (genericity)

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/genericity.png "Обобщения")

**Обобщения** – это возможность создавать параметризованный по типам код. 
_Например, программист который пишет библиотеку для связанных списков сталкивается с проблемой «какой тип задать для 
элементов этого списка?»._ Поскольку список может быть использован в различных ситуациях, поэтому нельзя сразу указать 
какие типы будут у его элементов (например все Int-ы). Это может оказаться крайне деспотичным и чрезмерно ограниченным решением.

Java программист прибегает к использованию Object, который является супертипом для всех объектов. 
Это решение тем не менее далеко от идеального, так как не дает возможность работать с примитивными типами 
(int, long, float и т.д.) и заставляет вставлять в программный код большое количество операторов динамического приведения типов.

Scala дает возможность определять обощающие классы (и методы) для того чтобы решить эту проблему. Давайте посмотрим на 
пример простейшего контейнера: ссылка, которая может быть пустой или указывать на объект некоторого типа.

<!-- code -->
```scala
    class Reference[T] {
        private var contents: T = _
        def set(value: T) { contents = value }
        def get: T = contents
    }
```
Класс `Referencе` является параметризованным типом, обозначенным `T`, который является типом этого элемента. 
Этот тип использует в теле класса как тип переменной contents и аргумент метода set,а также тип возвращаемого значения метода `get`.

Приведённый выше код вводит переменную в Scala, которая не требует явного преобразования типа в коде. 
Тем не менее интересно увидеть, что первоначальное значение данной переменной равно `_` , что представляет собой значение 
по умолчанию. Это значение по умолчанию является `0` для численных типов, `false` для `Boolean`, `()` для `Unit` и `null`
 для всех объектных типов.

Для того чтобы использовать `Reference` класс, необходимо указать, какой тип будет использоваться в качестве параметра `T`
, это и будет типом элемента содержащегося в ячейки. Для примера создадим ячейку содержащую `Int`. Мы можно написать 
это в следующем виде:

<!-- code -->
```scala
    object IntegerReference {
        def main(args: Array[String]) {
            val cell = new Reference[Int]
            cell.set(13)
            println("Reference contains the half of " + (cell.get * 2))
        }
    }
```

Как мы можем увидеть в этом примере, нет необходимости перед использование приводить тип к 
Int значение возвращаемое из get-метода. Также не получиться сохранить ничего кроме Int в переменной `cell`, так как 
она была объявлена как хранительница только Int'ов.
![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/scala-inheritance2.png "scala-inheritance")

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)