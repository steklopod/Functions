## Неявные/скрытые классы 

Это одна из самых сложных тем в языке Скала. Поэтому не стоит отчаиваться если вы не поймете ее с первого раза. 

**Скрытые классы** – это классы, которые позволяют нам неявное обращение к первичному конструктору, 
если класс находится в области его видимости.

Для создания неявного класса используется ключевое слово `implicit`.

При работе со скрытыми классами стоит учитывать следующее:

* Скрытые классы должны быть объявлены внутри другого класса, объекта или трейта.

* Скрытый класс может принимать только один не скрытый аргумент и конструктор.

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/implicit.jpg?raw=true "OOP.implicit")

_Рассмотрим простой пример:_

<!-- code -->
```scala
   object Squaring {
     implicit class Squarer(x: Int) {
       def numberSquaring[A](f: => A): Unit = {
         println(x + " * " + x + " = " + x * x);
       }
     }
   } 
   
   object SquaringDemo extends App{
      import Squaring._

      100 numberSquaring()        //100 * 100 = 10000
     }
```
___

### Неявные параметры

Метод может иметь неявный список параметров, помеченный ключевым словом `implicit` в начале списка параметров. 
Если параметры в этом списке параметров не передаются, как обычно, Scala будет смотреть, может ли он получить неявное 
значение правильного типа, и, если возможно, передать его автоматически.

Места Scala будут искать эти параметры в двух категориях:

1. Сначала Scala ищет неявные определения и неявные параметры, к которым можно получить доступ напрямую (без префикса)
 в точке, где вызывается метод с неявным блоком параметров.

2. Затем он ищет элементы, помеченные как `неявные` во всех `объектах-компаньенах`, связанных с неявным типом кандидата.
Более подробное руководство о том, где scala ищет implicits, можно найти в [FAQ](TODO)

В следующем примере мы определяем `sum` метод, который вычисляет сумму списка элементов, используя операции моноида
`add` и `unit`. Обратите внимание, что неявные значения не могут быть верхнего уровня.

<!-- code -->
```scala
    abstract class Monoid[A] {
      def add(x: A, y: A): A
      def unit: A
    }
    
    object ImplicitTest {
      implicit val stringMonoid: Monoid[String] = new Monoid[String] {
        def add(x: String, y: String): String = x concat y
        def unit: String = ""
      }
      
      implicit val intMonoid: Monoid[Int] = new Monoid[Int] {
        def add(x: Int, y: Int): Int = x + y
        def unit: Int = 0
      }
      
      def sum[A](xs: List[A])(implicit m: Monoid[A]): A =
        if (xs.isEmpty) m.unit
        else m.add(xs.head, sum(xs.tail))
        
      def main(args: Array[String]): Unit = {
        println(sum(List(1, 2, 3)))       // использует IntMonoid неявно
        println(sum(List("a", "b", "c"))) // использует StringMonoid неявно
      }
    }
```

`Monoid` определяет операцию, называемую `add` , которая объединяет пару `A` и возвращает другую `A` вместе с операцией,
 называемой `unit`, которая может создавать некоторые (конкретные) `A`.

Чтобы показать, как работают неявные параметры, мы сначала определяем моноиды `StringMonoid` и `IntMonoid` для строк и 
целых чисел соответственно. Ключевое слово `implicit` указывает, что соответствующий объект может использоваться неявно.

Метод `sum` принимает `List[A]` и возвращает `A`, который берет исходный `A` из `unit` и объединяет каждый следующий 
`A` в списке с тем, что с помощью метода `add`. Создание здесь параметра `m` неявно означает, что нам нужно предоставить 
параметр `xs`, когда мы вызываем метод, если Scala может найти `Monoid[A]` для использования для неявного параметра `m`.

В нашем main-методе мы называем `sum` дважды и предоставляем только параметр `xs`. Теперь Scala будет искать 
скрытые в области, упомянутой выше. Первый вызов суммы передает `List[Int]` для `xs`, это означает, что `A` является `Int`.
 Список неявных параметров с `m` не учитывается, поэтому Scala будет искать неявный тип `Monoid[Int]`. 
 Первое правило поиска читает
 
>Сначала Scala ищет неявные определения и неявные параметры, к которым можно получить доступ напрямую (без префикса) 
в точке, где вызывается метод с неявным блоком параметров.

`intMonoid` - это неявное определение, к которому можно получить доступ непосредственно в `main`. 
Он также имеет правильный тип, поэтому он автоматически передается методу суммы.

Второй вызов суммы передает `List[String]`, что означает, что `A` является строкой. Неявный поиск будет идти так же, 
как и с `Int`, но на этот раз найдет `stringMonoid` и будет автоматически передаваться как `m`.

Программа выведет

<!-- code -->
```scala
    6
    abc
```

_Если этот проект окажется полезным тебе - **нажми на кнопочку `star`** в правом верхнем углу._

[=> Неявные преобразования](https://github.com/steklopod/Functions/blob/master/src/main/resources/readmes/implicit_conversions.md)

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)