## Типаж (trait)

**`Типаж`** – это сущность, которая инкапсулирует поля или методы, которые потом могут быть использованы **для вставки в другие классы**.

Кроме наследования от суперкласса, в Scala классы также могут наследовать код из одного или несколько `типажей (traits`).

![alt text](https://github.com/steklopod/Functions/blob/master/src/main/resources/images/trait.png "trait")

Возможно, наиболее простой способ для понимания типажей Java-программистами это "закрыть глаза и представить, что есть 
интерфейсы, которые могут содержать методы с кодом...". Так вот эти сущности и будет аналогом типажей.  
В Scala когда класс наследуют trait, он имплементирует интерфейсы типажа и наследует весь код содержащийся в типаже.

Для того, чтобы увидеть пользу типажей, давайте рассмотрим классический пример: 
_упорядоченные объекты_. В Java объекты, которые можно сравнивать, реализуют интерфейс Comparable. 
В Scala мы можем сделать проще чем в Java определив аналог `Comparable` как типаж, который мы назовём `Ord`.

Когда объекты сравниваются могут использоваться около шести различных операций сравнения: 
`меньше (<)`, `меньше или равно (<=)`, `равно (=)`, `не равно (!=)`, `больше или равно (>=)`, `больше (>)`. 
Тем не менее, определение их всех утомительно, особенно если учесть что четыре из них могут быть определены используя 
два оставшихся. Таким образом если у нас есть операции равно и меньше, мы можем выразить другие оставшиеся через них. 
В Scala все это можно легко понять из следующего определения типажа:

<!-- code -->
```scala
     trait Ord {
         def < (that: Any): Boolean
         def <=(that: Any): Boolean = (this &lt; that) || (this == that)
         def > (that: Any): Boolean = !(this &lt;= that)
         def >=(that: Any): Boolean = !(this &lt; that)
     }
```

Это определение создаёт сразу новый тип называющийся `Ord`, которые играет туже роли, что и интерфейс Comparable в Java, 
и содержит в себе реализацию по умолчанию для трех операций сравнений через четвертый и одну абстрактную. 
Операция равенства и не равенства здесь не нужны, так как они по умолчанию существуют во всех объектах.

Тип `Any` который использовался выше в качестве типа, `является супер-типом` для всех типов в Scala. 
_Он может быть рассмотрен как более широкая версия Object в Java, так как он также является супертипом для таких базовых типов как Int, Float и т.д._

Для того чтобы сделать объекты класса сравниваемыми, достаточно определить операции равно и меньше, а затем включить их в 
класс `Ord`. В качестве примера давайте определим класс `Date` который представляет собой дату в григорианском календаре. 
Такие даты состоят из дня, месяца и года, которые представлены в виде целого числа. 
Поэтому мы запишем первые строки класса `Date` следующим образом:

<!-- code -->
```scala
     class Date(y: Int, m: Int, d: Int) extends Ord {
         def year  = y
         def month = m
         def day   = d
         override def toString(): String = year + "" + month + "" + day
```

Важной частью здесь является определение `extends Ord` которое следует после имени класса и параметров.  
Оно определяет что Date класс наследует типаж `Ord`.

Затем мы перепишем метод equals, наследованный из `Object`, для того, чтобы он правильно сравнивал даты на основе их полей. 
Реализация `equals` по умолчанию не пригодна для использования, поскольку в Java объекты сравниваются физически 
(объекты в памяти). Мы приведём следующее определение:

<!-- code -->
```scala
    override def equals(that: Any): Boolean =
        that.isInstanceOf[Date] && {
            val o = that.asInstanceOf[Date]
            o.day == day  && o.month == month  && o.year == year
    }
```

Этот метод использует предопределённый метод `isInstanceOf` и `asInstanceOf`. Первый из них (isInstanceOf) соответствует 
оператору _instanceof в Java_, и возвращает `true` в том и только в том случае если объект к которому он применяется 
является объектом данного типа. Второй (`asInstanceOf`) соответствует _оператору приведения типа в Java_: 
если объект является объектом данного типа, он будет рассмотрен таким образом, иначе будет брошено исключение `ClassCastException`.

В итоге, последним методом который будет быть определён является операция меньше. Она использует предопределённым методом 
`error`, который кидает исключение с со строкой-сообщением.

<!-- code -->
```scala
    def < (that: Any): Boolean = {
        if (!that.isInstanceOf[Date])
            error("cannot compare " + that + " and a Date")
        val o = that.asInstanceOf[Date]
        (year < o.year) ||
        (year == o.year && (month < o.month ||
        (month == o.month && day < o.day)))
    }
```

Этим мы завершаем определение класса `Date`. Экземпляры этого класса могут быть трактоваться как дата и  как 
сравниваемые объекты. Более того, они определяют шесть предикатов сравнения упомянутых выше: 
`equals` и `<` указаны непосредственно в определение класса `Dat`e и другие наследуются от типажа `Ord`.

_Если этот проект окажется полезным тебе - нажми на кнопочку `star` в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)