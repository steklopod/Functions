## Кейс-классы и сопоставление с образцом

`Кейс-классы` похожи на обычные классы с несколькими ключевыми различиями, которые мы рассмотрим. 
_Кейс-классы_ хороши для моделирования неизменяемых данных. На следующем этапе мы увидим, как они полезны при 
[сопоставлении по шаблону](https://github.com/steklopod/Functions/blob/master/src/main/resources/pattern_matching.md).

<!-- code -->
```scala
    case class Book(isbn: String)
    
    val frankenstein = Book("978-0486282114")
```
Обратите внимание, что ключевое слово `new` не использовалось для создания экземпляра класса `Book`. Это связано с тем, 
что в классах классов по умолчанию применяется метод `apply`, который заботится о построении объекта.

Когда вы создаете `кейс-класс` с параметрами, параметры являются общедоступными.

<!-- code -->
```scala
    case class Message(sender: String, recipient: String, body: String)
    val message1 = Message("guillaume@tut.by", "jorge@catalonia.ru", "Это вы?")
    
    println(message1.sender)                  // guillaume@tut.by
    message1.sender = "travis@washington.us"  // не скомпилируется
```

Вы не можете переопределить `message1.sender`, потому что это `val` (т.е. неизменяемый). В случае классов можно 
использовать `var`, но **это не рекомендуется**.

### Сравнение

**Кейс-классы сравниваются по структуре, а не по ссылке:**

<!-- code -->
```scala
    case class Message(sender: String, recipient: String, body: String)
    
    val message2 = Message("guillaume@tut.by", "jorge@catalonia.ru", "Это вы?")
    val message3 = Message("guillaume@tut.by", "jorge@catalonia.ru", "Это вы?")
    val messagesAreTheSame = message2 == message3  // true
```

Хотя `message2` и `message3` относятся к разным объектам, значение каждого объекта равно.

### Копирование

Вы можете создать (неглубокую) копию экземпляра кейс-класса, просто используя метод копирования. 
Вы можете изменить аргументы конструктора.

<!-- code -->
```scala
    case class Message(sender: String, recipient: String, body: String)
    
    val message4 = Message("sender@bretagne.fr", "recipient@washington.us", "Текст сообщения")
    val message5 = message4.copy(sender = message4.recipient, recipient = "claire@bourgogne.fr")
    
        message5.sender    // recipient@washington.us
        message5.recipient // claire@bourgogne.fr
        message5.body      // "Текст сообщения"
```
___

Одним из часто встречающихся в программировании типов данных являются `деревья`. Например интерпретаторы или компиляторы 
обычно представляют программы в виде дерева, XML документ — это тоже дерево, некоторые типа контейнеров также основаны 
на деревьях, например красно-чёрное дерево.

На примере небольшой программы-калькулятора мы увидим как деревья представлены в Scala и как ими можно манипулировать. 
Задача этой программы будет работа с очень простыми арифметическими выражениями состоящих из суммы, целых констант
 и переменных. Вот парочка примеров таких выражений: `1+2` и `(x+x) +(7+y)`.

Во-первых мы должны решить как мы будет представлять эти выражения. Один из наиболее естественных способов – в виде дерева, 
у которого `узлы являются операцией` (в нашем примере это сложение), а `листья будут значениями` (у нас константы или переменные).

В Java такое дерево может быть создано используя абстрактный суперкласс для деревьев и набором конкретных подклассов 
для каждого узела или листа. В функциональном языке программирования можно использовать алгебраические типы данных 
для этих же целей. Scala реализуют `концепцию кейс-классов` которые представляют из себя что-то среднее. 
Здесь мы покажем, как они могут быть использованы для определения деревьев в нашем примере:

<!-- code -->
```scala
    abstract class Tree
    
    case class Sum(l: Tree, r: Tree) extends Tree
    case class Var(n: String) extends Tree
    case class Const(v: Int) extends Tree
```

В этом примере классы `Sum`, `Var` и `Const` объявлены как `кейс-классы` и это значит то, что они отличаются от 
стандартных классах в следующем:

* ключевое слово `new` не обязательно для создания объектов этих классов (можно написать `Const(5)` вместо new Const(5));

* `get-функция` автоматически определяется для параметров конструктора (таким образом возможно получить значение 
параметра `v` некоторого объекта c класса `Const` просто написав `c.v`);

* методы `equals` и `hashCode` по умолчанию реализованы таким образом что они работают со структурой объекта, а не с 
его идентификатором.

* метод `toString` определяется по-умолчанию таким образом, что выдает значение в виде «исходного кода» 
(например выражение `x+1` выдаст `Sum( Var(x), Const(1) )` );

* экземпляры этих классов могут быть про сканированы используя сопоставление по шаблону (мы увидим это далее).

Теперь, так как мы определили типы данных для представления наших арифметических выражений, мы можем 
`начать определять операции для работа с ними`. Представим, что наши переменные живут в некоторой среде обитания (enviroment) 
и мы сейчас приступим к описанию функции, которая вычисляет выражение в именно в этой конкретной среде. 
Задача среды – дать нам возможность узнать какое конкретно значение имеет переменная в ней. 
_Например, выражение `x+1` при вычислении в среде в которой переменной `x` присвоено значение `5`, `{x → 5}`, даст в результате `6`._

Поэтому мы хотим найти способ запрограммировать эту среды обитания наших переменных. Мы можем конечно использовать 
некоторые ассоциативные структуры данных, такие как хэш-таблица, но гораздо интересней то, что мы можем использовать 
непосредственно функции! Среда на самом деле ничто иное, как функция которая связывает значение переменной и её имя. 
Среда `{x → 5}` приведенное выше может быть легко написано на Scala в виде:

`{ case "x" => 5 }`

Это обозначение задаёт функцию, которая при передачи `x в качестве аргумента` `возвращает целое число 5` или 
`кидает исключение во всех других случаях.`

Прежде чем написать функцию-вычислитель давайте присвоим имя типу среды. Мы можем конечно использовать тип 
`String=>Int` для среды, но если мы введём отдельное имя, то это упростит программу и сделает дальнейшие изменения легче. 
В Scala это делается следующим обозначением:

<!-- code -->
```scala
    type Enviroment = String => Int
```

С этого момента тип **Enviroment** может быть использован как сокращённое обозначение типа функции из `String в Int`.

Теперь мы можем дать определении функции-вычислителя. В принципе всё очень просто:

* значение сумму двух выражений – сумма каждого значения выражения;

* значение переменной получается напрямую из окружения;

* значение константы есть сама по себе константа.

Выразить это на Scala можно так:

<!-- code -->
```scala
    def eval(t:Tree, env:Enviroment): Int = t match {
        case Sum(left,right) => eval(left,env) + eval (right, env)
        case Var(n)          => env(n)
        case Const(v)        => v
    }
```

`Функция-вычислитель (eval)` осуществляет `сопоставление по шаблону` на дереве `t`. Поясним приведённый выше код функции:

1. Вначале она проверяет является ли дерево `t` классом `Sum`, и если это так, то привязывает левую ветку к переменной 
`left` и правую ветку `к` переменной `right`, а затем выполняет вычисление выражений следующих за стрелкой; 
эти выражения могут использовать переменные слева от стрелки (`left` и `right`);

2. Если первая проверка не увенчалась успехом, значит дерево не `Sum`, и она переходит на проверку — «может быть `t` это `Var`?»
 Если это так, то происходит привязка имени содержащегося в узле `Var` к переменной `n` и переходит к правой части выражения;
 
3. Если вторая проверка также провалилась, то есть `t` это не `Sum` и не `Var`, она проверяет «может быть это `Const`?», 
и если это так, она привязывает значение содержавшееся в узле `Const` к переменной `v` и выполняет правую часть;

4. Если все проверки провалились, появиться `исключение`, что будет являться сигналом что о провале сопоставлении 
по шаблону. Это может случиться только если еще есть какие-то объявленные, но неучтённые подклассы `Tree`.

Мы видим что основная идея сопоставление по шаблону заключается в том, чтобы попытаться сопоставить параметры набору 
шаблонов, и как только шаблон совпадает, получить и присвоить имя различным частям выражения. Затем следует выполнение 
некоторого кода, который обычно используют эти именованные части.

Временный пользователь объектно-ориентированного подхода программирования может быть удивлён почему мы не определили 
`eval` как метод класса `Tree` и его подклассов. Действительно, мы могли бы это сделать, так как Scala позволяет 
определять методы в кейс-классах также, как и в нормальных классах. Принятие решения использовать ли сопоставление по 
шаблону или методы по большому счету будет является делом вкуса, но при выборе следует учитывать такой фактор как расширяемость:

* Когда используются методы легко добавить новый тип узлов просто определив для этого подкласс `Tree`. 
С другой стороны добавление новой операции для всего дерева больно утомительна – требуется изменять все `подклассы Tree`;

* Когда используется сопоставление по шаблону ситуация обратная: добавление нового типа узла требует изменение всех функций,
 которые осуществляют сопоставление по шаблонам, для того, чтобы учесть во внимание новый узел; 
 с другой стороны добавление новой операции осуществляется просто добавлением её как новой независимой функцией.
 
Для дальнейшего изучения сопоставления по шаблону давайте определим другую операцию: `взятие производной`. 
Читатель возможно помнит следующие правила относительно этой операции:

<!-- code -->
```scala
    def derive(t: Tree, v: String): Tree = t match {
        case Sum(l, r)          => Sum(derive(l, v), derive(r, v))
        case Var(n) if (v == n) => Const(1)
        case _                  => Const(0)
    }
```

Эта функция определяет два новых понятия связанных с сопоставлением по шаблону. 

Первое это то, что `case` - выражение для переменной может иметь «предохранитель» (guard) в виде выражения следующего 
после ключевого слова `if`. Этот предохранитель предотвращает сопоставление по шаблону `если выражение не true`. 
Здесь он используются для того, чтобы убедиться в том, что мы возвращаем константу `1`, только если имя переменной 
такое же что и имя по которой мы берём производную. 

Другая используемая здесь новая фишка в сопоставлении по шаблону – `использование символа-джокера (wild-card) “_”`, 
который может подходить к любому значению.

Мы не будем сейчас изучать всю мощь сопоставлений по шаблону и остановимся на этой теме прямо сейчас для того, 
чтобы оставить этот документ краткими. Мы ведь все ещё хотим увидеть как две наши функции будут работать в реальном примере?
 Для этих целей давайте напишем простую main функцию которая осуществляет несколько простых операций над 
 выражением `(x+x) + (7+y)`: сначала она вычисляет её значение при `{x->5, y ->7}`, а затем вычисляет её производную по `x` и по `y`.

<!-- code -->
```scala
    def main(args: Array[String]) {
        val exp: Tree        = Sum(Sum(Var("x"),Var("x")),Sum(Const(7),Var("y")))
        val env: Environment = { case "x" => 5 case "y" => 7 }
        
            println("Expression: " + exp)
            println("Evaluation with x=5, y=7: " + eval(exp, env))
            println("Derivative relative to x:\n " + derive(exp, "x"))
            println("Derivative relative to y:\n " + derive(exp, "y"))
    }
```

Выполнение этой программы выведет на экран:

<!-- code -->
```sbtshell
    Expression: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))
    Evaluation with x=5, y=7: 24
    Derivative relative to x:
    Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))
    Derivative relative to y:
    Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))
```

Рассмотрев полученный результат, мы можем увидеть, что результат вычисления производных следовало бы упростить 
прежде чем выводить на экран. Определение функции упрощающей выражение, используя [сопоставление по шаблону](https://github.com/steklopod/Functions/blob/master/src/main/resources/pattern_matching.md), 
будет интересной (но удивительно хитрущей) задачей.

[<= содержание](https://github.com/steklopod/Functions/blob/master/readme.md)